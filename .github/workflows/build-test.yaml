# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-maven
name: Test and Publish Container Image

on:
  release:
    types: [published]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    # Use a matrix to run JVM and native builds concurrently and reuse common steps
    strategy:
      matrix:
        include:
          - type: jvm
            distribution: temurin
            dockerfile: src/main/docker/Dockerfile.jvm
            versionSuffix: ""
            mavenArgs: ""
          - type: native
            distribution: graalvm
            dockerfile: src/main/docker/Dockerfile.native
            versionSuffix: "-native"
            mavenArgs: "-Dnative -Dquarkus.native.container-build=true"
    env:
      APP_NAME: kafka-synth-client
    permissions:
      contents: write
      packages: write
      id-token: write

    steps:
      - uses: actions/checkout@v6

      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          java-version: '21'
          distribution: ${{ matrix.distribution }}
          cache: maven

      - uses: actions/setup-node@v6
        with:
          node-version-file: 'src/main/webui/.nvmrc'
      - name: Install Node Dependencies
        working-directory: src/main/webui
        run: npm install
      - name: Build Web UI
        working-directory: src/main/webui
        run: npm run build

      - name: Run Unit Tests
        run: mvn clean test

      - name: Package Application
        run: mvn package -DskipTests ${{ matrix.mavenArgs }}

      - name: Prepare image name and version (lowercase)
        run: |
          # compute lowercase image id and version for GHCR (GHCR requires lowercase names)
          IMAGE_ID="ghcr.io/${{ github.repository_owner }}/$APP_NAME"
          IMAGE_ID=$(echo "$IMAGE_ID" | tr '[:upper:]' '[:lower:]')
          VERSION="${{ github.ref_name }}${{ matrix.versionSuffix }}"
          echo "IMAGE_ID=$IMAGE_ID" >> $GITHUB_ENV
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      - name: Set up QEMU and Buildx for multi-platform builds
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push multi-arch image
        id: docker_build
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ env.IMAGE_ID }}:${{ env.VERSION }}

      - name: Generate SBOM for the pushed image
        # install syft and generate SBOM for the pushed multi-arch image
        run: |
          set -euo pipefail
          echo "Installing syft"
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
          echo "Generating SBOM for ${{ env.IMAGE_ID }}:${{ env.VERSION }}"
          syft ${{ env.IMAGE_ID }}:${{ env.VERSION }} -o json > sbom.json

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v6
        with:
          name: sbom-${{ env.VERSION }}
          path: sbom.json

      - name: Upload SBOM to GitHub Release
        # users expect supply-chain metadata to live alongside the release artifacts
        if: github.event_name == 'release'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          cp sbom.json "sbom-${{ env.VERSION }}.spdx.json"
          gh release upload "${{ github.ref_name }}" "sbom-${{ env.VERSION }}.spdx.json" --clobber

      - name: Install cosign (sigstore) for image signing
        # install cosign binary directly so we don't rely on an action reference
        run: |
          set -euo pipefail
          COSIGN_VERSION=v3.0.4
          echo "Installing cosign ${COSIGN_VERSION}"
          curl -sSL "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64" -o /usr/local/bin/cosign
          chmod +x /usr/local/bin/cosign
          cosign version

      - name: Sign image with cosign (keyless)
        # keyless signing uses GitHub Actions OIDC (id-token permission required) and should sign the pushed digest
        run: |
          set -euo pipefail
          IMAGE_REF="${{ env.IMAGE_ID }}@${{ steps.docker_build.outputs.digest }}"
          echo "Signing image ${IMAGE_REF} (keyless)"
          cosign sign --yes "${IMAGE_REF}"

      - name: Attach SBOM attestation with cosign
        run: |
          set -euo pipefail
          test -f sbom.json
          IMAGE_REF="${{ env.IMAGE_ID }}@${{ steps.docker_build.outputs.digest }}"
          echo "Attesting SBOM to ${IMAGE_REF}"
          cosign attest --yes --predicate sbom.json --type spdxjson "${IMAGE_REF}"

      - name: Show pushed images (registry client may show manifests)
        run: docker images --format "{{.Repository}}:{{.Tag}} {{.ID}}"
